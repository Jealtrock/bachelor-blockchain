\chapter{Tankstelle - Server}
Die Kommunikation zwischen der Tankstelle und einem Fahrzeug soll durch eine Restful API geschehen. Das Fahrzeug soll imstande sein, durch das Abfragen der implementierten API, einer vorübergehenden ID zugeordnet zu werden, welche für den gesamten Tankvorgang notwendig ist. Auch der Tank - Prozess soll durch gezielte Abfragen an die API gestartet und beendet werden. In einem abschließenden Schritt soll die Tankstellen API die anfallenden Kosten, sowie die notwendige IOTA - Adresse, übermitteln.

Dem Besitzer der Tankstelle muss es möglich sein durch autorisierte Anfragen an die API die IOTA - Adressen zu wechseln oder diesen Prozess durch das hinterlegen eines IOTA - Seed zu automatisieren. Die Adressen, die für den Bezahlvorgang verwendet werden sollen, werden für den autorisierten Besitzer der Tankstelle frei verfügbar sein.

Es ist wichtig anzumerken, dass diese Art der Kommunikation eine von vielen Möglichkeiten ist, dieses Projekt zu realisieren. Im Endeffekt sind folgende Grundvoraussetzung zu erfüllen:
\begin{itemize}
	\item Dem Kunden darf es nicht möglich sein den IOTA Seed einzusehen.
  \item Hinterlegte IOTA - Adressen dürfen für unbeschränkt viele Zahlungseingänge, aber ausschließlich für einen Zahlungsausgang verwendet werden.
  \item Die Aktualisierung der IOTA - Adresse kann automatisiert werden, dies birgt jedoch das Risiko, einen validen IOTA Seed dem Netzwerk zu hinterlegen.
  \item Autorisierten Personen muss es gestattet sein, neue IOTA - Adressen der Datenbank hinzuzufügen.
  \item Das System muss Zugang zu dem IOTA - Tangle besitzen und imstande sein dieser Transaktionen hinzufügen zu können.
\end{itemize}

\section{Projektaufbau}
In dem folgenden Unterkapitel wird der grobe Projektaufbau skizziert sowie die Installation der notwendigen Software aufgeführt. Diese Schritte sind notwendig um den Prototypen den Anforderungen entsprechend ausführen zu lassen.
\subsection{Vorbedingungen}
\subsubsection{NodeJS}
NodeJS ist eine asynchrone, auf “Events” basierende, JavaScript Laufzeitumgebung, die es ermöglicht mehrere Anfragen zu derselben Zeit abzuarbeiten. Dadurch entstehen niedrige Latenzen zwischen dem Client und dem Server. Des Weiteren verfügt NodeJS über eine “EventLoop” die der in Web - Browsern bekannten “EventLoops” sehr ähnelt. Anders als aus Frameworks bekannt, startet die “EventLoop” mit Beginn des ausführenden Scripts und endet sobald keine "`Callbacks"' mehr vorhanden sind. Dank dieses Verhaltens ist NodeJS für das Entwickeln einer Restful API prädestiniert. [27](QUELLE)

Die Installation von NodeJS gestaltet sich für das Betriebssystem Windows nicht besonders herausfordernd. Auf der Homepage von NodeJS wird eine ausführbare Datei angeboten, welche alle nötigen Programme beinhaltet.

\subsubsection{NPM}
Durch die Installation von NodeJS wird der hauseigene sogenannte “node package manager” (kurz npm) zusätzlich installiert. Dieses Werkzeug befähigt Nutzer vorhandene und publizierte Module für die Entwicklung in NodeJS herunterzuladen oder eigene Module der Öffentlichkeit zur Verfügung zu stellen. Um npm nutzen zu können wird eine funktionierende “Bash” vorausgesetzt.

\subsubsection{PowerShell}
Um mit NodeJS effektiv arbeiten zu können benötigen alle Programmierer eine geeignete Bash (Shell). Viele Unix und Linux Distributionen besitzen eine geeignete vorinstallierte Bash die für die meisten Befehle ausreicht. Um mit Windows entsprechend zu arbeiten, empfiehlt sich die Installation von der PowerShell [28](QUELLE).

\subsubsection{Express.js}
Eine Restful API basiert auf Anfragen (requests) die an einen Server übermittelt werden. Grundsätzlich folgt auf einen request stets eine Antwort (response). Ein handelsüblicher Webserver verkörpert dieses Prinzip. Sobald in einem Webbrowser die Anfrage zu einer IP - Adresse verschickt wird, antwortet dieser mit den hinterlegten Ressourcen (Meistens vorhandene .html Dateien) (siehe Grundlagen \ref{RestfulAPI} auf Seite \pageref{RestfulAPI}). Um angefragte Routen wie bspw. “/getAddress” zu verarbeiten, welche keine HTML - Daten als Antwort verlangen, werden sogenannte “Middlewares” geschrieben. Diese nehmen den angefragten Request entgegen, verarbeiten ihn und senden entweder einen abschließenden Response oder geben den Request weiter an die nächste Middleware - Instanz. Dieser Vorgang wird so lange durchgeführt bis eine beendende Antwort an den Client zurückgesendet wird.

Express.js ist ein Modul für NodeJS, dass dem Programmierer ermöglicht vollwertige Middlewares zu erstellen. Die Installation gestaltet sich sehr leicht. Voraussetzung sind eine funktionierende Bash, sowie der Paketmanager ”npm”. In der Shell wird folgendes Kommando ausgeführt:

\begin{lstlisting}[language=bash]
npm install express
\end{lstlisting}

Falls das Paket in einem Projekt abgespeichert werden soll, empfiehlt sich das folgende Kommando:

\begin{lstlisting}[language=bash]
npm install --save express
\end{lstlisting}

\subsubsection{MySQL}
Eine MySQL - Datenbank wird für das permanente Speichern der IOTA - Adresse genutzt. Um die Datenbank aufzusetzen empfiehlt sich das Hilfsprogramm XAMPP [29](FOOTNOTE). Durch dieses Programm kann eine MySQL Datenbank gestartet und über eine lokale Webpage konfiguriert werden. Nach dem Download der ausführbaren Installationsdatei wird diese mit einem Doppelklick gestartet. Im Anschluss genügt es den Installationsanweisungen zu folgen. Nicht alle Komponenten sind notwendig, es genügen der Apache Webserver und die MySQL Unterstützung. XAMPP bietet eine GUI (graphical user interface) mit der neben einer Datenbank auch ein Apache Server gestartet werden kann. Dieser Apache Server ist notwendig um die lokale Konfigurations - Webseite für die MySQL Datenbank zu hosten.

\subsubsection{Port Weiterleitung}
Damit die API auf zukünftige Anfragen außerhalb des lokalen Systems reagieren kann, muss das Netzwerk entsprechend eingerichtet werden. Der Firewall des zentralen Routers (standard Gateway) werden entsprechende Regeln hinzugefügt, die Anfragen auf den Port 1717 (Dieser Port ist frei wählbar und wurde für dieses Projekt festgelegt) zulassen. Anfragen, die den genannten Port adressieren, werden zu dem Endgerät weitergeleitet, auf welchem die API instanziiert ist.

\subsection{Projektabgrenzung}
Eine geeignete Kommunikation innerhalb eines Netzwerkes kann auf verschiedene Weisen geschehen. Das Verwenden einer Restful API bietet den Vorteil Informationen und Ressourcen auf vielfältige Art und Weise auszutauschen. Die Kommunikation kann dementsprechend mithilfe eines JSON - Objektes oder über andere Protokolle wie XML oder URL-Encoding gelöst werden. Anders als andere Netzwerk Kommunikationstechniken wie bspw. SOAP sind Serverressourcen direkt adressierbar, ohne das im Vorhinein der Inhalt der Anfrage ausgewertet werden muss [30](QUELLE).

\section{Umsetzung}
Mit dem Start der API überprüft das System ob eine JSON-Datei hinterlegt ist, in der die notwendigen Datenbank-Anmeldeinformationen gespeichert sind. Falls diese Datei nicht vorhanden ist, wird eine neue erstellt, indem die Informationen abgefragt werden. Sobald der Zugang zur Datenbank gesichert ist, startet der HTTP-Server und wartet anschließend auf dem eingerichteten Port auf kommende Anfragen. An diesem Punkt sind verschiedene Routen eingerichtet, die sowohl Daten verfügbar machen, mit Daten interagieren oder Daten abspeichern. Diese verschiedenen Routen und ihre Funktionen werden im Folgenden erläutert.(PICTURE)

\subsection{Tank-Vorgang}
Der Tankvorgang würde in einer realen Implementierung erst starten können sobald das Fahrzeug vorgefahren ist, die Zapfsäule ausgewählt und die Zapfpistole des notwendigen Kraftstoff in den Tankstutzen eingeführt wurde. Während dessen verbindet das Fahrzeug sich mit dem lokalen Netzwerk mit gegebenen Mitteln. Dieser gesamte Vorgang kann entweder von dem Fahrer oder durch einen Automatismus erfolgen und ist Voraussetzung für den kommenden Tank-Prozesses. Der vorliegende Prototyp schreibt dafür keine Regeln vor.

Die API hört auf den Port 1717 und erwartet dort folgende Anfragen:
\begin{itemize}
	\item \{IP-Adresse des Servers\}/fueling/getStationInfo
  \item \{IP-Adresse des Servers\}/fueling/initializeFueling?\{ID der Zapfsäule\} \& \{Kraftstoffart\} 
  \item \{IP-Adresse des Servers\}/fueling/startFueling?\{Kundennummer\}
  \item \{IP-Adresse des Servers\}/fueling/pauseFueling?\{Kundennummer\}
	\item \{IP-Adresse des Servers\}/fueling/endFueling?\{Kundennummer\}
  \item \{IP-Adresse des Servers\}/fueling/getFueling?\{Kundennummer\}
\end{itemize}

\paragraph{getStationInfo}
Die Tankstelle liefert die aktuellen Tank-Preise der verschiedenen Kraftstofftypen an das Fahrzeug in Form eines JSON-Objektes.

\begin{lstlisting}[language=JavaScript]
router.get('/getStationInfo', (req, resp, next) => {

	resp.status(200).json(Petrolstation.stationInfoObject);

});
\end{lstlisting}

\paragraph{initializeFueling}
Die API empfängt von dem Fahrzeug die gewählte Kraftstoffart und die ID der Zapfsäule, an der der Tank-Vorgang gestartet werden soll. Diese Daten werden gemeinsam mit einer neu erstellten Kundennummer in der Datenbank hinterlegt. Diese spezielle Zapfsäule ist ab diesem Zeitpunkt für den Tank-Prozess vorbereitet und wird anschließend nur durch die Kundennummer ansprechbar sein. Der Kunde erhält als Antwort die erstellte Kundennummer und kann den Tankvorgang beginnen.

\begin{lstlisting}[language=JavaScript]
router.get('/initializeFueling', (req, resp, next) => {

	if(! (req.query.fuel_type && req.query.station)) return next('You missed the required parameter.');

	petrolstation.initialize_fueling(req.query.fuel_type, req.query.station, (err, result) => {

		if(err) return next(err);

		resp.status(200).json({
			id: result
		});

	});

});
\end{lstlisting}

\paragraph{startFueling}
Diese Anfrage startet den Tankvorgang des Fahrzeuges und benötigt die in der Initialisierung vergebene Kundennummer zur Freigabe. Das Tanken wird durch eine Schleife simuliert. Es wird davon ausgegangen, dass innerhalb einer Sekunde ein Liter bzw. Kilowattstunde in das Fahrzeug getankt wird. Die Kosten werden entsprechend aufgerechnet.

\begin{lstlisting}[language=JavaScript]
router.get('/startFueling', check_for_initialisation, (req, resp, next) => {	

	if(petrolstation.start_fueling(req.query.id)){	
		resp.status(200).json({
			message: 'Start fueling.'
		});		
	}else{
		next('Anything went wrong.');
	}

});
\end{lstlisting}

\paragraph{pauseFueling}
Auch diese Anfrage muss die in der Initialisierung vergebene Kundennummer übergeben um das Fahrzeug für den aktuellen Tank-Prozess zu autorisieren. Diese Anfrage pausiert den Tankvorgang der durch “startFueling” begonnen wurde. Technisch wird das erstellte Intervall gelöscht und die momentanen Beträge gespeichert.

\begin{lstlisting}[language=JavaScript]
router.get('/pauseFueling', check_for_initialisation, (req, resp, next) => {

	petrolstation.pause_fueling(req.query.id, (err, success) => {

		if(err) return next(err);

		resp.status(200).json({
			message: 'Pause fueling'
		});

	});

});
\end{lstlisting}

\paragraph{endFueling}
Diese Anfrage muss die entsprechende Kundennummer enthalten und beendet den Tank-Prozess. Das Kundenfahrzeug erhält die Anzahl der getankten Einheiten, die zugehörigen Kosten und die aktuelle IOTA-Adresse als JSON-Objekt. Die Zapfsäule wird für eine erneute Initialisierung freigegeben. Die Kosten sowie der Betrag der getankten Einheiten werden in der Datenbank zu der entsprechenden Kundennummer gespeichert.

\begin{lstlisting}[language=JavaScript]
router.get('/endFueling', check_for_initialisation, (req, resp, next) => {

	petrolstation.end_fueling(req.query.id, (err, result) => {

		if(err) return next(err);

		resp.status(200).json({
			data: result
		});

	});
	
});
\end{lstlisting}

\paragraph{getFueling}
Der Kunde kann über diese Anfrage die Menge des getankten Kraftstoffes und die Kosten erfahren. Dafür muss die entsprechende Kundennummer übergeben werden. Die Antwort geschieht in Form eines JSON-Objektes.

\begin{lstlisting}[language=JavaScript]
router.get('/getFueling', check_for_initialisation, (req, resp, next) => {	

	resp.status(200).json({

			data: petrolstation.get_fueling(req.query.id)

	});

});
\end{lstlisting}

\subsection{Neue Adresse generieren}
Ausschließlich ein autorisierter Benutzer darf die Anfrage an die API stellen, eine neue Adresse, für den Empfang von Zahlungen, zu generieren. Die Autorisierung geschieht im Prototypen durch die "`basic access authentication"' Methode, bei der ein Hash, erstellt aus einem Benutzernamen und Passwort, an den Header einer HTTP Anfrage an gehangen wird. Die API kann diese Daten auslesen und die Resource freigeben.

\begin{lstlisting}[language=JavaScript]
var authorizeUser = function(username, password, cb){

	db.connect();

	let db_call = new Promise((resolve, reject) => {

		db.get_user_password(username, (err, rows) => {
			db.end();
			if (!arr_is_empty(rows) && passwordHash.verify(password, rows[0].password)) resolve(true);
			else resolve(false);

		});

	});

	db_call.then(value => {
		cb(null, value);
	});

}
\end{lstlisting}

Die autorisierte Anfrage an den Server muss an diese Route gesendet werden:
\begin{itemize}
	\item \{IP-Adresse des Servers\}/user/addNewAddress"' 
\end{itemize}
Serverseitig werden nach und nach Adressen generiert, solange bis eine gefunden wurde die noch nicht in der IOTA Tangle "`attached"' ist. Dementsprechend wird eine verbundene "`IOTA Full-Node API"' angesprochen, die Zugriff zu der Tangle hat. Nachdem eine neue Adresse gefunden wurde, wird eine wertlose Transaktion erstellt. Diese ist dafür zuständig, die neue Adresse in der Tangle zu hinterlegen.

\begin{lstlisting}[language=JavaScript]
PetrolstatioIotaInterface.prototype.addNewAddressToTangle = async function(callback) {

	//Get the newest unused address
	let get_address = new Promise((res, rej)=>{

		this.iota.api.getNewAddress(this.seed, {index: 0}, (err, address)=>{
			if(err){
				callback(err);
				rej(err);
			}else{
				callback(null, address);
				res(address);
			}
		});

	});

	//Put the data into the transfers Array
	try{
		let address = await get_address;
		let depth = 3;
		let minWeightMagnitude = 14;
		let transfers = [{
			value: 0,
			address: address
		}];

		//send the transfer to the tangle
		this.iota.api.sendTransfer(this.seed, depth, minWeightMagnitude, transfers, (err, object)=>{
			if(err){
				console.log(err);
			}else{
				console.log(object);
			}
		});

	}catch(err){
		callback(err);
	}

};
\end{lstlisting}

Die Adresse wird zudem in der lokalen MySQL Datenbank gespeichert. Als Antwort erhält der autorisierte Benutzer die neue Adresse zusammen mit den veralteten Adressen aus der Datenbank:

\begin{lstlisting}[language=JavaScript]
{
    "newAddress": "LOZMZOKJ...AWSQFFXX",
    "affectedRows": 1,
    "savedAddresses": [
        "A9XZMWXP...TRKKUHZD",
        "GHDGOJFL...TVOETV9Z",
        "YOUZCEEZ...AKNKQSRW",
        "LOZMZOKJ...AWSQFFXX"
    ],
    "message": "Address is successfully added to the database and will be used for later transactions."
}
\end{lstlisting}